/*
 * generated by Xtext 2.20.0
 */
package io.mdsl.validation;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.EValidatorRegistrar;

import com.google.common.collect.Lists;
import com.google.common.collect.Sets;

import io.mdsl.apiDescription.ApiDescriptionPackage;
import io.mdsl.apiDescription.AtomicParameter;
import io.mdsl.apiDescription.DataTransferRepresentation;
import io.mdsl.apiDescription.ElementStructure;
import io.mdsl.apiDescription.EndpointContract;
import io.mdsl.apiDescription.EndpointInstance;
import io.mdsl.apiDescription.EndpointList;
import io.mdsl.apiDescription.HTTPBinding;
import io.mdsl.apiDescription.HTTPOperationBinding;
import io.mdsl.apiDescription.HTTPParameter;
import io.mdsl.apiDescription.HTTPParameterBinding;
import io.mdsl.apiDescription.HTTPVerb;
import io.mdsl.apiDescription.Operation;
import io.mdsl.apiDescription.ReportBinding;
import io.mdsl.apiDescription.SecurityBinding;
import io.mdsl.apiDescription.SecurityPolicies;
import io.mdsl.apiDescription.SecurityPolicy;
import io.mdsl.apiDescription.StatusReport;
import io.mdsl.apiDescription.StatusReports;
import io.mdsl.apiDescription.TechnologyBinding;
import io.mdsl.apiDescription.TreeNode;
import io.mdsl.exception.MDSLException;

/**
 * This class contains custom validation rules.
 *
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class HTTPBindingValidator extends AbstractMDSLValidator {

	@Override
	public void register(EValidatorRegistrar registrar) {
		// not needed for classes used as ComposedCheck
	}
	
	// TODO some more checks missing:
	
	// * TODO (H) check that all link relations are bound and that bound ones refer existing abstract one
	
	// * HTTP verbs unique in one resource binding (generator will report)
	// * location/(sub-)resource URIs make sense
	// * could also check MIME types etc.
	
	@Check void operationsActuallyDefinedInEndpointType(final HTTPOperationBinding httpOperationBinding) {
		if(httpOperationBinding.getMethod()==HTTPVerb.TRACE || httpOperationBinding.getMethod()==HTTPVerb.HEAD || httpOperationBinding.getMethod()==HTTPVerb.OPTIONS) {
		    warning("Operation " + httpOperationBinding.getBoundOperation() + " is bound to " + httpOperationBinding.getMethod().getName() + ", an HTTP verb that is not seen often in APIs. Prefer POST, PUT, PATCH, GET, DELETE", httpOperationBinding,
				ApiDescriptionPackage.eINSTANCE.getHTTPOperationBinding_Method());
		}
		
		checkWhetherAllOperationsInContractAreBound(httpOperationBinding);
		checkOperationExistenceInContract(httpOperationBinding); // TODO NYI
		checkErrorReportBindings(httpOperationBinding);
		checkSecurityPolicyBindings(httpOperationBinding);
	}
	
	private void checkSecurityPolicyBindings(HTTPOperationBinding httpOperationBinding) {

		EList<SecurityBinding> sbl = httpOperationBinding.getSecurityBindings();

		EndpointContract ec = findContract(httpOperationBinding);
		Operation op = findOperation(ec, httpOperationBinding.getBoundOperation());

		SecurityPolicies secPols = null;
		for (Operation operation : ec.getOps()) {
			if(operation.getName().equals(httpOperationBinding.getBoundOperation())) {
				secPols = operation.getPolicies();
			}
		}
		if(secPols==null&&(sbl!=null&&sbl.size()>0)) {
			error("No policy definitions found in endpoint type operation, but the operation binding has one or more.", 
					httpOperationBinding,
					ApiDescriptionPackage.eINSTANCE.getHTTPOperationBinding_SecurityBindings());
			return;
		}
		for(SecurityBinding sb : sbl) {
			boolean found=false;
			for(SecurityPolicy sp: secPols.getPolicyList())
				if(sp.getName().equals(sb.getName()))
					found=true;
			if(!found)
				error("No policy definition for " + sb.getName() + " found in endpoint type operation.", 
						httpOperationBinding,
						ApiDescriptionPackage.eINSTANCE.getHTTPOperationBinding_SecurityBindings());
		}
	}

	private void checkErrorReportBindings(HTTPOperationBinding httpOperationBinding) {

		EList<ReportBinding> rpl = httpOperationBinding.getReportBindings();

		EndpointContract ec = findContract(httpOperationBinding);
		Operation op = findOperation(ec, httpOperationBinding.getBoundOperation());

		StatusReports responseReports=null;
		for (Operation operation : ec.getOps()) {
			if(operation.getName().equals(httpOperationBinding.getBoundOperation())) {
				responseReports = operation.getReports();
			}
		}
		if(responseReports==null&&(rpl!=null&&rpl.size()>0)) {
			error("No report definitions found in endpoint type operation, but the operation binding has one or more.", 
					httpOperationBinding,
					ApiDescriptionPackage.eINSTANCE.getHTTPOperationBinding_ReportBindings());
			return;
		}
		for(ReportBinding rp : rpl) {
			boolean found=false;
			for(StatusReport sr: responseReports.getReportList())
				if(sr.getName().equals(rp.getName()))
					found=true;
			if(!found)
				error("No report definition for " + rp.getName() + " found in endpoint type operation.", 
						httpOperationBinding,
						ApiDescriptionPackage.eINSTANCE.getHTTPOperationBinding_ReportBindings());
		}
	}

	private boolean checkWhetherAllOperationsInContractAreBound(HTTPOperationBinding httpOperationBinding) {
		
		EndpointContract ec = findContract(httpOperationBinding);
		
		for (Operation operation : ec.getOps()) {
			if(operation.getName().equals(httpOperationBinding.getBoundOperation())) 
				return true;
		}
		
		error("Bound operation " + httpOperationBinding.getBoundOperation() + " is not defined in the endpoint type " + ec.getName() + ". Add it there or delete binding here.", httpOperationBinding,
				ApiDescriptionPackage.eINSTANCE.getHTTPOperationBinding_BoundOperation());
		
		return false;
		
	}

	private EndpointContract findContract(HTTPOperationBinding httpOperationBinding) {
		TechnologyBinding tp = (TechnologyBinding) httpOperationBinding.eContainer().eContainer().eContainer().eContainer();
		EndpointList eil = (EndpointList) tp.eContainer().eContainer();
		return eil.getContract();
	}

	private boolean checkOperationExistenceInContract(HTTPOperationBinding httpOperationBinding) {
		return true; // TODO NYI 
	}

	@Check 
	void elementsActuallyDefinedInRequestPayload(final HTTPParameterBinding parameterBinding) {

		HTTPOperationBinding httpOperationBinding = (HTTPOperationBinding) parameterBinding.eContainer();
		EndpointContract ec = findContract(httpOperationBinding);
		Operation op = findOperation(ec, httpOperationBinding.getBoundOperation());
		
		if(!isPresentInRequestPayload(parameterBinding.getBoundParameter(), op))
			error("Bound parameter " + parameterBinding.getBoundParameter() + " is not defined in the bound operation " + op.getName() + ". Add it there or delete binding here.", parameterBinding,
						ApiDescriptionPackage.eINSTANCE.getHTTPParameterBinding_BoundParameter());

	}

	private boolean isPresentInRequestPayload(String boundParameter, Operation op) {

		DataTransferRepresentation rm = op.getRequestMessage();
		
		ElementStructure structure = rm.getPayload(); // TODO look in header too?
		
		if(structure==null)
			return false;
		
		return checkElements(structure, boundParameter);
	}

	private boolean checkElements(ElementStructure structure, String boundParameter) {
	
		// partially duplicating code from generator utils here:
		List<AtomicParameter> atomicParameterList = Lists.newLinkedList();
		
		if (structure.getApl() != null) {
			atomicParameterList.add(structure.getApl().getFirst());
			atomicParameterList.addAll(structure.getApl().getNextap());
		} else if (structure.getNp() != null && structure.getNp().getAtomP() != null) {
			atomicParameterList.add(structure.getNp().getAtomP());
		} else if (structure.getNp() != null && structure.getNp().getTr() != null) {
			// find referenced explicit type and call same method again 
			return checkElements(structure.getNp().getTr().getDcref().getStructure(), boundParameter);
		} else if (structure.getPt() != null) {
			// not the most efficient way to do this:
			List<TreeNode> nodes = Lists.newLinkedList();
			nodes.add(structure.getPt().getFirst());
			nodes.addAll(structure.getPt().getNexttn());
			for(TreeNode nextLevel1Node : nodes) 
				if(nextLevel1Node.getPn()!=null && nextLevel1Node.getPn().getAtomP()!=null)
					atomicParameterList.add(nextLevel1Node.getPn().getAtomP());
		} else if (structure.getNp().getGenP() != null) {
			if(structure.getNp().getGenP().getName()!=null && structure.getNp().getGenP().getName().equals(boundParameter))
				return true;
		}
		
		for(AtomicParameter atomicParameter : atomicParameterList) 
			if(atomicParameter.getRat()!=null && atomicParameter.getRat().getName()!=null && atomicParameter.getRat().getName().equals(boundParameter)) {
				// if(atomicParameter.getRat()!=null)
				//	System.out.println("Checking " + atomicParameter.getRat().getName());
				return true;
			}
		
		return false;
	}
	
	private Operation findOperation(EndpointContract ec, String boundOperation) {
		for(Operation operation : ec.getOps())
			if(operation.getName().equals(boundOperation)) 
				return operation;
		return null;
	}
	
	@Check
	public void doNotAllowBODYMappingForGETsAndDELETEs(final HTTPOperationBinding httpOperationBinding) {
		// element bindings to BODY is ok if operation method is not GET or DELETE (FORM deprecated)
		if (!(httpOperationBinding.getMethod() == HTTPVerb.GET || httpOperationBinding.getMethod() == HTTPVerb.DELETE))
			return;

		for (HTTPParameterBinding parameterBinding : EcoreUtil2.eAllOfType(httpOperationBinding, HTTPParameterBinding.class).stream()
				.filter(pb -> pb.getParameterMapping() != null && pb.getParameterMapping() != null && (pb.getParameterMapping() == HTTPParameter.BODY /* || pb.getParameterMapping().getHttp() == HTTPParameter.FORM */))
				.collect(Collectors.toList())) {
			error("HTTP operations with the verbs GET and DELETE do not support BODY parameters.", parameterBinding,
					ApiDescriptionPackage.eINSTANCE.getHTTPParameterBinding_ParameterMapping()); // Literals.HTTP_PARAMETER_BINDING__PARAMETER_MAPPING);
		}
	}

	/*
	@Check
	public void warnUserIfParametersAreUsedInOperationsThatAreMappedToBODY(final HTTPOperationBinding httpOperationBinding) {
		// PATH, QUERY, and COOKIE parameters are okay, if operation is mapped to GET or
		// DELETE
		if (httpOperationBinding.getMethod() == HTTPVerb.GET || httpOperationBinding.getMethod() == HTTPVerb.DELETE)
			return;

		for (HTTPParameterBinding parameterBinding : EcoreUtil2.eAllOfType(httpOperationBinding, HTTPParameterBinding.class).stream()
				.filter(pb -> pb.getParameterMapping() != null && pb.getParameterMapping().getHttp() != null
						&& (pb.getParameterMapping().getHttp() == HTTPParameter.COOKIE || pb.getParameterMapping().getHttp() == HTTPParameter.PATH || pb.getParameterMapping().getHttp() == HTTPParameter.QUERY))
				.collect(Collectors.toList())) {
			warning("Known limitation in Open API (OAS) generator: We currently map the complete data structure for " + httpOperationBinding.getMethod().toString()
					+ " operations into the BODY. Thus, this mapping will be ignored in the OAS generator.", parameterBinding,
					ApiDescriptionPackage.Literals.HTTP_PARAMETER_BINDING__PARAMETER_MAPPING);
		}
	}
	*/

	// TODO this one does not work properly in all cases, so disabled for now
	// @Check
	public void doNotAllowDifferentPATHBindingsInHTTPBinding(final HTTPBinding httpBinding) {
		Set<Set<String>> operationParameterBindings = Sets.newHashSet();

		// bug: assumes only one binding to be present!
		if(httpBinding.getEb().size() == 0)
			return;
		
		// TODO iterate or remove validator, get(0) no longer works in V5  
		
		for (HTTPOperationBinding operationBinding : httpBinding.getEb().get(0).getOpsB()) {
			Set<String> params = operationBinding.getParameterBindings().stream().filter(pb -> pb.getParameterMapping() != null && pb.getParameterMapping() != null && pb.getParameterMapping() == HTTPParameter.PATH)
					.map(pb -> pb.getBoundParameter()).collect(Collectors.toSet());
			if(!params.isEmpty())
				operationParameterBindings.add(params);
		}
		if (operationParameterBindings.size() > 1)
			error("This HTTP binding contains operations with different PATH parameter mappings. Please ensure that all operation map the same PATH parameters.", httpBinding,
					ApiDescriptionPackage.eINSTANCE.getHTTPBinding_Eb()); // Literals.HTTP_BINDING__EB);
	}
}
