/*
 * generated by Xtext 2.20.0
 */
package io.mdsl.validation;

import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.EValidatorRegistrar;

import io.mdsl.apiDescription.ApiDescriptionPackage;
import io.mdsl.apiDescription.EndpointInstance;
import io.mdsl.apiDescription.EndpointList;
import io.mdsl.apiDescription.HTTPBinding;
import io.mdsl.apiDescription.JavaBinding;
import io.mdsl.apiDescription.ProtocolBinding;
import io.mdsl.apiDescription.Provider;
import io.mdsl.apiDescription.ServiceSpecification;
import io.mdsl.apiDescription.TechnologyBinding;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class BasicBindingValidator extends AbstractAPIDescriptionValidator {

	@Override
	public void register(EValidatorRegistrar registrar) {
		// not needed for classes used as ComposedCheck
	}
	
	@Check
	public void bindingExistenceValidator(final ServiceSpecification specRoot) {
		info("MDSL API Linter: only checking very few binding-related rules in " + specRoot.getName() + " in current version", specRoot, ApiDescriptionPackage.Literals.SERVICE_SPECIFICATION__NAME);
		
		// could/should check:
		//
		// * HTTP verbs unique in one binding; location/(sub-)resource URIs make sense
		// * Java location meets package/class name conventions 
		// * GRPC: tbd
		// * listed operations actually exist 
		// * listed elements actually exist in top-level APL/PT
		// * tbc
		
		EList<Provider> providers = specRoot.getProviders();
		for (Provider provider : providers) {
			EList<EndpointList> endpointListInProvider = provider.getEpl();
			// TODO check grammar: 2x list?
			for(EndpointList endpointList: endpointListInProvider) {
				EList<EndpointInstance> endpoints = endpointList.getEndpoints();
				for(EndpointInstance endpoint: endpoints) {
					EList<TechnologyBinding> techBindings = endpoint.getTechBindings();
					for(int i=0;i<techBindings.size();i++) {
						TechnologyBinding techBinding = techBindings.get(i);
						ProtocolBinding protBinding = techBinding.getProtBinding();
						if(protBinding.getHttp()!=null) {
							checkHTTPBinding(specRoot, provider.getName(), endpoint.getName(), protBinding.getHttp());
						}
						else if (protBinding.getJava()!=null) {
							checkJavaBinding(specRoot, provider.getName(), endpoint.getName(), protBinding.getJava());
						}
						else if (protBinding.getGrpc()!=null) {
							info("Specification includes a provider endpoint binding of type GRPC", protBinding, ApiDescriptionPackage.Literals.PROTOCOL_BINDING__GRPC);
						}
						else if (protBinding.getOther()!=null) {
							// TODO get value of "other" (utility method)
							info("Specification includes a provider endpoint binding of other type " /* + protBinding.getOther().toString() */, protBinding, ApiDescriptionPackage.Literals.PROTOCOL_BINDING__OTHER);
						}
						else 
							throw new IllegalArgumentException("Unknown binding type."); // can't get here
					}
				}
			}
		}
	}

	private void checkJavaBinding(ServiceSpecification specRoot, String pName, String address, JavaBinding java) {
		info("Specification " + specRoot.getName() + " includes a provider " + pName + " with endpoint binding of type Java, location is " + address, java, ApiDescriptionPackage.Literals.JAVA_BINDING__JAVA);
		// TODO check that operations and elements are actually defined in referenced endpoint type 
	}

	private void checkHTTPBinding(ServiceSpecification specRoot, String pName, String address, HTTPBinding http) {
		info("Specification " + specRoot.getName() + " includes a provider " + pName + " with endpoint binding of type HTTP, location is " + address, http, ApiDescriptionPackage.Literals.HTTP_BINDING__HTTP);
		// TODO check that operations and elements are actually defined in referenced endpoint type 
		// TODO check HTTP verbs; could also check MIME types etc. 
	}
}
