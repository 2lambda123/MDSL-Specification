/*
 * Copyright 2018-2020 Olaf Zimmermann (a.k.a. socadk)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

grammar io.mdsl.APIDescription with org.eclipse.xtext.common.Terminals

/*  
---
title: Microservices Domain Specific Language (MDSL) Grammar
author: Olaf Zimmermann
copyright: Olaf Zimmermann, 2018-2020. All rights reserved.
version: "4.2"
---
*/ 

generate apiDescription "http://www.mdsl.io/APIDescription"

ServiceSpecification hidden(WS, ML_COMMENT, SL_COMMENT): 
	'API' 'description' name=ID
    ('version' svi=semanticVersioningIdentifier)?  
    ('usage' 'context' reach=Visibility 'for' direction+=DirectionList)?
	('description' description=STRING)?
    types+=DataContract*
	contracts+=(EndpointContract | ChannelContract)+	
	slas+=SLATemplate*
	providers+=(Provider | MessageBroker)*
	clients+=(Client | MessageEndpoint)*
	gateways+=Gateway*
	realizations+=ProviderImplementation*
	('IPA')? // IPA is the inversion of API; optional
;

Visibility: 'PUBLIC_API' | 'COMMUNITY_API' | 'SOLUTION_INTERNAL_API' | STRING;

DirectionList:
	primaryDirection=Direction ('and' otherDirection=Direction)?
;

Direction: 'FRONTEND_INTEGRATION' | 'BACKEND_INTEGRATION' | STRING;

// ** This MDSL grammar defines several sub-languages (orthogonal to each other): 
//
// * A) schema (data types)
// * B) service endpoints (including operations) 
// * C) instance-level concepts (provider, client, gateway; implementation)


// *** Part A: data contract/types 

DataContract:
	'data' 'type' name=ID 
	('version' svi=semanticVersioningIdentifier)? 
	structure=ElementStructure
	default=DefaultValue? // moved here in v3; still experimental
;


// *** Part B: service endpoint contracts (with operations)

ElementStructure: 
	pf=ParameterForest | pt=ParameterTree | apl=AtomicParameterList  | np=SingleParameterNode
;

ParameterForest:
	classifier=PatternStereotype?
	'[' ptl=ParameterTreeList ']' 
	;

ChannelContract:
	'channel' name=ID
	('of' 'type' types+=ChannelType (',' types+=ChannelType)*)?
	conversationType=(RequestReplyChannel|OneWayChannel)
;

BindingValue:
	{BindingValue} str=STRING | {BindingValue} number=INT | bool=('true' | 'false')
;

BindingParameter:
	name=STRING ':' value=(BindingValue|BindingParams)
;

BindingParams:
	'{'
		params+=BindingParameter
		(',' params+=BindingParameter)*
	'}'
;

BasicParameterWithDescription:
	paramName=ID ':' type=BasicDataType (',' description=STRING)?
;

ChannelPathWithParams:
	'path' path=STRING
	('with' 
		params+=BasicParameterWithDescription
		(',' params+=BasicParameterWithDescription)?
	)?
;

RequestReplyChannel:
	request=RequestChannel
	reply=ReplyChannel

;

RequestChannel:
	'request' 'message' name=ID 
		(('description' description=STRING)? &
		'on' path=ChannelPathWithParams)
		'expecting' payload=Payload
		('where' whereClauses+=WhereClauses (',' whereClauses+=WhereClauses)*)?
		('bindings' 'for' protocol=ProtocolBinding bindings=BindingParams)? 
;

ReplyChannel:
	'reply' 'message' name=ID 
		(('description' description=STRING)? &
		'on' path=ChannelPathWithParams)
		'delivering' payload=Payload
		('where' whereClauses+=WhereClauses (',' whereClauses+=WhereClauses)*)?
		('bindings' 'for' protocol=ProtocolBinding bindings=BindingParams)?
;

Payload:
	schema=DataTransferRepresentation	
	('as' messageType=MessageType)?
;

OneWayChannel:
	(('description' description=STRING)? &
	'on' path=ChannelPathWithParams)
	(subscribe?='accepts' | publish?='produces' | acceptsAndProduces='accepts' 'and' 'produces') message=Message
	('where' whereClauses+=WhereClauses (',' whereClauses+=WhereClauses)*)?
	('bindings' 'for' protocol=ProtocolBinding bindings=BindingParams)?
;

Message:
	'message' name=ID 
	('description' description=STRING)?
	(deliveringPayload?='delivering' | expectingPayload?='expecting') payload=Payload
;
WhereClauses:
	MessageExpireWhereClause
	|	SequenceIdWhereClause
    |	CorrelationIdWhereClause
;
MessageExpireWhereClause:
	'MESSAGE_EXPIRES' 'in' messageExpire=INT messageExpireUnit=MessageExpireUnit
;
SequenceIdWhereClause:
	'SEQUENCE_ID' 'is' expression=STRING
;
CorrelationIdWhereClause:
	'CORRELATION_ID' 'is' source=STRING
;

enum MessageExpireUnit:
	s | m // seconds or minutes
;
enum MessageType:
	COMMAND_MESSAGE | EVENT_MESSAGE | DOCUMENT_MESSAGE
;
enum ChannelType:
	POINT_TO_POINT | PUBLISH_SUBSCRIBE | DATA_TYPE | INVALID_MESSAGE | DEAD_LETTER | GUARANTEED_DELIVERY
;
 


ParameterTreeList:
	first=ParameterTree (';' next+=ParameterTree)*
;

ParameterTree:
	classifier=PatternStereotype? 
	(name=STRING':')?
	'{' 
	  first=TreeNode ((','|'|') nexttn+=TreeNode)* 
	'}' 
	card=Cardinality? 
;

TreeNode:
	pn=SingleParameterNode | apl=AtomicParameterList | children=ParameterTree
;

SingleParameterNode: 
	genP=GenericParameter | atomP=AtomicParameter | tr=TypeReference 
;

GenericParameter: 
	 name=STRING // this makes it possible to only have a name/id, but no role (yet)
	| p='P' // unspecified, P stands for 'Parameter' or 'PayloadPart' or 'Placeholder'
	| name=STRING ":" 'P'
;

TypeReference: 
	classifier=PatternStereotype? 
	(name=STRING':')? dcref=[DataContract] 
	card=Cardinality?
;

AtomicParameterList:
	classifier=PatternStereotype? 
	(name=STRING':')? 
	'(' first=AtomicParameter ((','|'|') nextap+=AtomicParameter)* ')' 
	card=Cardinality? 	
;

AtomicParameter: 
	classifier=PatternStereotype? 
	rat=RoleAndType
	card=Cardinality?
;

RoleAndType:
    (name=STRING':')? role=ParameterRole ('<'btype=BasicDataType'>')? 
;

DefaultValue:
	'default' 'is' default=STRING // TODO tbd: do we need something more concrete here?
;

PatternStereotype:
    '<<' (pattern=MapPattern | eip=EipPattern | name=ID) '>>' 
;

EipPattern:
	// added in version 3.1.1 (June 2020):
	'Command_Message' | 'Document_Message' | 'Event_Message'
;

MapPattern:
	'API_Key' | 'Context_Representation' | 'Error_Report' | 'Request_Bundle' | 'Request_Condition' | 'Wish_List' | 'Wish_Template' 
	| 'Embedded_Entity' | 'Linked_Information_Holder' | 'Annotated_Parameter_Collection' | 'Pagination' 
	| 'Data_Element' | 'Identifier_Element' | 'Link_Element' | 'Metadata_Element'  | 'Control_Metadata' | 'Aggregated_Metadata' | 'Provenance_Metadata' 
	| STRING   
;

ParameterRole:
	  'D' // (Atomic) Data Value, Entity or Value Object from DDD
	| 'MD' // // e.g. in Annotated Parameter Collection: {MD,(MD,D),(MD,D),...}
	| 'ID' // Identifier (globally or locally unique, not network accessible
	| 'L' // e.g. URI. Linked Information Holder: {(ID,D1,..,DN,L} for HATEOAS, e.g. "nextPage":Link<Customer>* 
	| 'Data'
	| 'Metadata'
	| 'Identifier'
	| 'Link' 
;

BasicDataType:
 	'bool' | 'int' | 'long' | 'double' | 'string' | 'raw' | 'void' // 'record', 'map' and 'array' do not make sense here
	;

Cardinality:
	zeroOrOne='?' | zeroOrMore='*' | atLeastOne='+' | exactlyOne='!'
;


// *** Part B: service endpoint contracts (with operations)

EndpointContract:
	('endpoint' | 'channel' ) 'type' name=ID
	('version' svi=semanticVersioningIdentifier)? 
	('serves' 'as' primaryRole=ResourceRole ('and' otherRoles+=ResourceRole)* 'role'?)?
	sp=SecurityPolicy?
	('exposes' ops+=Operation+)? // optional because early incomplete specifications do not have to expose any operations 
;

semanticVersioningIdentifier: STRING; // correct format to be checked by API linters 

ResourceRole: 'PROCESSING_RESOURCE' | 'INFORMATION_HOLDER_RESOURCE' | 'OPERATIONAL_DATA_HOLDER' | 'MASTER_DATA_HOLDER' | 'REFERENCE_DATA_HOLDER' | 'TRANSFER_RESOURCE' | 'LOOKUP_RESOURCE' | 'DATA_TRANSFER_RESOURCE' | 'LINK_LOOKUP_RESOURCE'  | STRING;

Operation:
	('operation' | 'event' ) name=ID // 'event' is experimental still
	('version' svi=semanticVersioningIdentifier)?
	('with' 'responsibility' responsibility=OperationResponsibility)? 
	('in'  mep=MessageExchangePattern 'conversation')? 
	('expecting' requestMessage=DataTransferRepresentation)? // request message is optional
	('delivering' responseMessage=DataTransferRepresentation 
	  ('reporting' reportData=StatusReport)? // optional within 'delivering'
	)? // response message is optional for 'operation'
	sp=SecurityPolicy?
;

SecurityPolicy: 
	'protected' 'by' 'policy' securityObject+=ElementStructure+
;

StatusReport:
	(('error' | 'analytics') reportMessage+=ElementStructure)+ 
;

OperationResponsibility: cf='COMPUTATION_FUNCTION' | sco='STATE_CREATION_OPERATION' | ro='RETRIEVAL_OPERATION' | sto='STATE_TRANSITION_OPERATION' | ep='EVENT_PROCESSOR' | bap='BUSINESS_ACTIVITY_PROCESSOR' | other=STRING; // removed in v3.1.0: 'NOTIFICATION_OPERATION'

MessageExchangePattern: 'ONE_WAY' | 'REQUEST_REPLY' | 'NOTIFICATION' | STRING;	
	
DataTransferRepresentation:
	('headers' headers=ElementStructure)? 
	'payload' payload=ElementStructure // this could be an embedded XSD or JSON Schema (or an external one referenced via URI)
	('structured' 'as' ts=TypeSystem)? 
;

TypeSystem: 
	'MAP_TYPE' | 'JOLIE_TYPE' | 'JSON_SCHEMA' | 'XML_SCHEMA' |'PROTOCOL_BUFFER' | 'AVRO_SCHEMA' | 'THRIFT_TYPE' | 'GRAPHQL_SDL' | 'OTHER' 
;


// *** C.1: provider/endpoint part 

Provider:
	(ap= 'API' 'provider' | ms= 'Message' 'sender') // MOM support is experimental
	name=ID
	('contained' 'in' parent=[Provider])? // TODO document this "subresourcing" (OAS has it), still experimental
	epl+=EndpointList+ // [Q] is list here (+) and in EndpointInstance needed (*)? 
	('under' 'conditions' tsandcs=STRING | 'with' 'provider' sla=SLA)? // neither Ts&Cs nor SLA must be present
	('provider' 'governance'  evolStrat=EvolutionStrategy)? 
;

EndpointList:	
	'offers' contract=[EndpointContract] // one endpoint can only offer a single contract (but provider can have multiple endpoints)
	endpoints+=EndpointInstance* // optional; several endpoints per contract mean redundant deployment (or different SLAs for same functionality) 
;

EndpointInstance: 
	'at' 'endpoint' 'location' name=STRING
	pb+=TechnologyBinding*
	('with' 'endpoint' sla=SLA)? // SLA is optional
	('endpoint' 'governance'  evolStrat=EvolutionStrategy)?
;

MessageBroker:
	'message' 'broker' name=ID
	('description' description=STRING)?
	'exposes' epl+=AsyncEndpoint (',' epl+=AsyncEndpoint)?
	
;
AsyncEndpoint:
	contract=[ServiceSpecification]
	'at' 'location' location=STRING
	pb=TechnologyBinding
	('bindings' bindings=BindingParams)?
	('policy' name=ID 'realized' 'using' (securityPolicy=OASSecurity | other=STRING) ('in' securityPolicyExpression=STRING)?)? 
;


// ** technology binding (simple/advanced)

TechnologyBinding:
	'via' 'protocol' protBinding=ProtocolBinding 
;

ProtocolBinding:
	http=HTTPBinding | java=JavaBinding | grpc=GRPCBinding | other=OtherBinding
;

// the binding concept is inspired by HTTP and Java in V3
HTTPBinding:
	http='HTTP' ('binding' opsB+=HTTPOperationBinding+)?
;

HTTPOperationBinding:
	// TODO would like to reference [Operation] here; Xtext runs through but editor does not show references (?)  
	'operation' boundOperation=ID 'to' method=HTTPVerb ('at' subresource=STRING)? 
	pB+=HTTPParameterBinding*
	rB+=ReportBinding* // TODO Java?
	sB+=SecurityBinding* // TODO Java?
	('accepts' inContentTypes+=MIMEType)*
	('replies' outCcontentTypes+=MIMEType)*
;

// TODO would like to use [ElementStructure] here but it does not have name=ID (?)
HTTPParameterBinding:
	'element' boundParameter=ID 'realized' 'as' pm=HTTPParameterMapping 'parameter' ('with' details=ElementStructure)? // type vs. instance elementStructureInstance rule?
;

HTTPParameterMapping:
	http=HTTPParameter
;

enum HTTPVerb: GET | PUT | POST | PATCH | DELETE | HEAD | OPTIONS
;

enum HTTPParameter: PATH | QUERY | FORM | COOKIE | BODY // semantic rule: BODY is default
;

MIMEType: json='application/json' | xml='application/xml' | custom=STRING // experimental, TODO support full RFC
;


ReportBinding:
	// [StatusReport] reference?
	'report' name=ID 'realized' 'as' httpStatusCode=INT ('with' details=ElementStructure)? // TODO test/document
;

SecurityBinding:
	// [SecurityPolicy] reference?
	'policy' name=ID 'realized' 'as' (http=OASSecurity | other=STRING) ('with' details=ElementStructure)?
;

// TODO support full OAuth Flow Object here, as expected by OAS (etc.)
enum OASSecurity: BASIC_AUTHENTICATION | API_KEY | OAUTH_FLOW | OTHER_MEANS | TBC // BASIC is default (?)
;


JavaBinding:
	java='Java' (binding='binding' ('package' package=STRING)? opsBinding+=JavaOperationBinding+)?
;

JavaOperationBinding:
	'operation' boundOperation=ID 'to' method=STRING // no subresource here
	pB+=JavaParameterBinding*
;

JavaParameterBinding:
	'element' boundParameter=ID 'realized' 'as' pm=JavaParameter 'type' // HTTP has more here
;

enum JavaParameter: byte | short | int | long | float | double | boolean | char | String; // String needed? 


GRPCBinding:
	gRPC='gRPC' (binding='binding' opsBinding+=GRPCOperationBinding+)?
;

GRPCOperationBinding:
	'operation' boundOperation=ID ('to' method=STRING)? ('as' so=StreamingOption 'stream')?
;

enum StreamingOption:
	client | server | bidirectional // if not present, "unary" is assumed
;


OtherBinding:
    soap='SOAP_HTTP' | avro='Avro_RPC' | thrift='Thrift' | amqp='AMQP' | jms='JMS_ActiveMQ' | stomp='STOMP' | kafka='Kafka' | mqtt='MQTT' | other=STRING 
;

// removed v2 binding rules, were experimental, now deprecated (?):
// V2ParameterBinding:
//	('path' 'parameters' pp=identifierList)
//	| ('query' 'parameters' qp=identifierList)
//	| ('form' 'parameters' fp=identifierList)
//	| default='default' 'body'
// ;

// identifierList:
//	'(' name1=ID (',' moreNames+=ID )* ')'
// ;


// **** SLA

SLA:
	'SLA' (builtin=InternalSLA | external=[SLATemplate])
;

SLATemplate:
	'SLA' 'template'
	name=ID
	slas+=InternalSLA
;

InternalSLA:
	('type' type=SLAType)? // note: not checked/used at present (semantic check?) 
	slos+=SLO+
	('penalty' penalties=STRING)?
	('notification' reporting=STRING)?
	rp=RatePlan? 
	rl+=RateLimit*
;

RatePlan:
	'rate' 'plan' ('FREEMIUM' | "SUBSCRIPTION" | "USAGE_BASED") // note: actual pricing not modeled yet
;

RateLimit:
	'rate' 'limit' (none='NONE' | "MAX_CALLS" callRate=SimpleMeasurement | "DATA_QUOTA" dataRate=SimpleMeasurement) "within" interval=SimpleMeasurement// note: just a PoC/demo, can be modeled much better (see pattern/books)	
;

enum SLAType : NONE  | IMPLICIT | INFORMAL | QUALITATIVE | QUANTITATIVE
;

SLO:
	'objective' 
    name=ID
	qualityGoal=STRING
	// ':'  
	measurement=Measurement
;

Measurement:
	sm=SimpleMeasurement | lz=LandingZone
;

SimpleMeasurement:
	value=INT
	unitOfMeasure=('hours' | 'minutes' | 'seconds' | 'MB' | 'GB'| ID | STRING)? // not a full specification of units/measures, just a PoC/demo
;

LandingZone:
	'minimal' s=SimpleMeasurement
	'target' t=SimpleMeasurement
	('optimal' o=SimpleMeasurement)?
;

// **** evolution

enum EvolutionStrategy: 
	ETERNAL_LIFETIME | LIMITED_GUARANTEED_LIFETIME | TWO_IN_PRODUCTION | AGGRESSIVE_OBSOLESCENCE | EXPERIMENTAL_PREVIEW // MAPs
	| OTHER_STRATEGY | UNDISCLOSED // default: UNDISCLOSED
;


// *** C.2: Client 

Client:
	'API' 'client' name=ID
     cons+=Consumption+
;

Consumption: 
	'consumes' contract=[EndpointContract]
	// if present, the provider reference creates a static binding between client and server:
	('from' providerReference=[Provider] | 'through' gatewayReference=[Gateway])? // could also go down to endpoint level
	('via' 'protocol'  binding+=ProtocolBinding)? // must match provider-side information (linter!)
;

MessageEndpoint:
	'message' 'endpoint' name=ID
	('of' 'type' types+=MessageEndpointType (',' types+=MessageEndpointType)*)?
	('serves' 'as' primaryRole=ResourceRole (',' otherRoles+=ResourceRole)* 'role'?)?
	('description' description=STRING)?
	'uses' 
		('channels' ':'
			channelsNoBroker+=AsyncConsumptionWithProtocolBinding (',' channelsNoBroker+=AsyncConsumptionWithProtocolBinding)*
		)?
	(channels+=AsyncConsumptionFromBroker (',' channels+=AsyncConsumptionFromBroker)*)?
;

enum MessageEndpointType:
	TRANSACTIONAL_CLIENT | POLLING_CONSUMER | EVENT_DRIVEN_CONSUMER | IDEMPOTENT_RECEIVER | MESSAGING_GATEWAY | MESSAGING_MAPPER | COMPETEING_CONSUMER | MESSAGE_DISPATCHER | SELECTIVE_CONSUMER | DURABLE_SUBSCRIBER | SERRVICE_ACTIVATOR
;

AsyncConsumptionFromBroker:
	'from' broker=[MessageBroker] ':'
	channels+=AsyncConsumptionNoProtocolBinding (',' channels+=AsyncConsumptionNoProtocolBinding)*
	(binding+=ProtocolBinding)?
;

Channel:
	ChannelContract | RequestChannel | ReplyChannel
;

AsyncConsumptionNoProtocolBinding:
	(channel=[Channel])
	(where=WhereConstruct)?
;

AsyncConsumptionWithProtocolBinding:
	(channel=[Channel])
	(where=WhereConstruct)?
	(binding+=ProtocolBinding)?
;


WhereConstruct:
	{WhereConstruct} 'where' 
	(whereClauses+=ConsumptionWhereClauses (',' whereClauses+=ConsumptionWhereClauses)*)?
		((',')? 'all' 'subscriptions' 'are' 'durable')?
;


ConsumptionWhereClauses:
		'consumed' 'if' leftExp=STRING op=BinaryOperator rightExpr=IfExpr
;

IfExpr:
	STRING | INT
;
BinaryOperator:
	'==' | '!=' | '>' | '<' | '<=' | '>='
;

// *** C.3: Gateway (experimental)

Gateway:
	('API' 'gateway' | 'Message' 'broker') name=ID // MOM support is experimental
	gateList+=Gate+
	('evolution' 'governance'  evolStrat=EvolutionStrategy)?
;

Gate:
	( 'offers' | 'publishes' )  upstreamContract+=[EndpointContract]+ // MOM support is experimental
	endpoints+=EndpointInstance+ 

     cons+=Consumption
     ('mediates' dts+=DataTransformation)*
;

DataTransformation:
	'from' indc=[DataContract] 'to' outdc=[DataContract]
;


// *** C.4: Provider Implementation (experimental)

ProviderImplementation:
	'API' 'provider' 'implementation'
	name=ID
	'realizes' upstreamBinding=[Provider]
	'in' platform=ImplementationTechnology
	('as' class=STRING ('extending' superclass=STRING)? // default assigned if not specified
	| 'with' 'binding' downstreamBinding=[Provider])? // reference to Java protocol binding (optional)
;

enum ImplementationTechnology: PlainJava | SpringMVC | vlingo | STRING
;	


// ** End of MDSL grammar 
