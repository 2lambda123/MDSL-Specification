/*
 * Copyright 2018-2021 Olaf Zimmermann (a.k.a. socadk)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

grammar io.mdsl.APIDescription with org.eclipse.xtext.common.Terminals

/*  
---
title: Microservices Domain Specific Language (MDSL) Language Specification
author: Olaf Zimmermann
copyright: Olaf Zimmermann, 2018-2021. All rights reserved.
version: "5.3.3: scenarios and flows; states and compensation; events"
---
*/ 

generate apiDescription "http://www.mdsl.io/APIDescription"

ServiceSpecification hidden(WS, ML_COMMENT, SL_COMMENT): 
	'API' 'description' name=ID
    ('version' svi=SemanticVersioningIdentifier)?  
    ('usage' 'context' reach=Visibility 'for' direction+=DirectionList)?
	('overview' description=STRING)? 
    types+=DataContract*
    links+=LinkContract* // under validation
    events+=EventTypes* // experimental preview 
    commands+=CommandTypes* // experimental preview
	contracts+=(EndpointContract|ChannelContract)* // ChannelContract: AsyncMDSL extension	
	slas+=SLATemplate*
	providers+=(Provider|MessageBroker)* // AsyncMDSL extension
	clients+=(Client|MessageEndpoint)* // AsyncMDSL extension
	gateways+=Gateway* // experimental preview (still) 
	orchestrations+=Orchestration* // experimental preview
	realizations+=ProviderImplementation* // under validation
	scenarios+=IntegrationScenario* // experimental preview
	('IPA')? // IPA is the inversion of API; optional preview
;

// ** This MDSL grammar defines several sub-languages (orthogonal to each other): 
//
// * A) schema (data types)
// * B) service endpoints (including operations) 
// * C) instance-level concepts (provider, client, gateway; implementation)
// * D) orchestration flows and integration scenarios (experimental)


Visibility: 'PUBLIC_API' | 'COMMUNITY_API' | 'SOLUTION_INTERNAL_API' | STRING;

DirectionList:
	primaryDirection=Direction ('and' otherDirection=Direction)?
;

Direction: 'FRONTEND_INTEGRATION' | 'BACKEND_INTEGRATION' | STRING;

SemanticVersioningIdentifier: STRING; // format could be checked by API linters

// *** Part A: data contract/types 

DataContract:
	'data' 'type' name=ID 
	('version' svi=SemanticVersioningIdentifier)? 
	structure=ElementStructure
	default=DefaultValue? // TODO moved here in V3; still an experimental preview
	// OAS: https://swagger.io/specification/#runtime-expression
;

// note: rule name could also be "RelationType": a relation is a typed link in context
LinkContract:
	'relation' 'type' name=ID // this is the type info
	('version' svi=SemanticVersioningIdentifier)? 
	'targets' (ept=[EndpointContract] | ('any'|'external') 'resource' ('at' urn=STRING)?)
	('action' operation=ID ('input' dataType=[DataContract])?)?
	 // HTTP Verb and MediaType added in HTTP binding for now
;

EventTypes: 
	'event' 'type' events+=EventType (',' events+=EventType)*
;

EventType:  
	name=ID (/*'content'*/ content=ElementStructure)? // the domain data reported, part of published language
	('version' svi=SemanticVersioningIdentifier)? // TODO test, document
;

CommandTypes:
	'command' 'type' commands+=CommandType (',' commands+=CommandType)*
;

CommandType:
	name=ID (/*'content'*/ subject=ElementStructure)? // the in/out data or the business object/item processed
	('version' svi=SemanticVersioningIdentifier)? // TODO test, document
;


// *** Part B: service endpoint contracts (with operations)

ElementStructure: 
	pf=ParameterForest | pt=ParameterTree | apl=AtomicParameterList  | np=SingleParameterNode
;

ParameterForest:
	classifier=PatternStereotype?
	'[' ptl=ParameterTreeList ']' 
	;


 
// Common parts:

ParameterTreeList:
	first=ParameterTree (';' next+=ParameterTree)*
;

ParameterTree:
	classifier=PatternStereotype? 
	(name=STRING':')?
	'{' 
	  first=TreeNode ((','|'|') nexttn+=TreeNode)* 
	'}' 
	card=Cardinality? 
;

TreeNode:
	pn=SingleParameterNode | apl=AtomicParameterList | children=ParameterTree
;

SingleParameterNode: 
	// Markdown-ish syntax for link reference was experimental, R<> caused problems earlier 
	genP=GenericParameter | atomP=AtomicParameter | tr=TypeReference // | lr=LinkReference
;

GenericParameter: 
	name=STRING // this makes it possible to only have a name/id, but no role (yet)
	| p='P' // unspecified, P stands for 'Parameter' or 'PayloadPart' or 'Placeholder'
	| name=STRING ":" 'P' // this option is not documented and tested much; could deprecate
;

/*
// experimental, causes compatibility issues (dcref in TypeReference rule might be null)
LinkTypeReference:
	'[' lcref=[LinkContract] ']' 
;
*/ 

TypeReference: 
	classifier=PatternStereotype? 
	(name=STRING':')? (dcref=[DataContract] /* lref=LinkTypeReference */)
	card=Cardinality?
;

AtomicParameterList:
	classifier=PatternStereotype? 
	(name=STRING':')? 
	'(' first=AtomicParameter ((','|'|') nextap+=AtomicParameter)* ')' 
	card=Cardinality? 	
;

AtomicParameter: 
	classifier=PatternStereotype? 
	rat=RoleAndType
	card=Cardinality?
;

RoleAndType: 
	// experimental  |'->' ec=[EndpointContract] taken out again
    (name=STRING':')? role=ParameterRole ('<'btype=BasicDataType'>' )? 
;


DefaultValue:
	'default' 'is' default=STRING // TODO tbd: do we need more here? e.g. an expression language
;

PatternStereotype:
    '<<' (pattern=MapPattern | eip=EipPattern | name=ID) '>>' 
;

EipPattern:
	'Command_Message' | 'Document_Message' | 'Event_Message'
;

MapPattern:
	'API_Key' | 'Context_Representation' | 'Error_Report' | 'Request_Bundle' | 'Request_Condition' | 'Wish_List' | 'Wish_Template' 
	| 'Embedded_Entity' | 'Linked_Information_Holder' | 'Annotated_Parameter_Collection' | 'Pagination' 
	| 'Data_Element' | 'Identifier_Element' | 'Link_Element' | 'Metadata_Element'  | 'Control_Metadata' | 'Aggregated_Metadata' | 'Provenance_Metadata' 
	| STRING   
;

ParameterRole:
	  'D' // (Atomic) Data Value, Entity or Value Object from DDD
	| 'MD' // // e.g. in Annotated Parameter Collection: {MD,(MD,D),(MD,D),...}
	| 'ID' // Identifier (globally or locally unique, not network accessible
	| 'L' // e.g. URI. Linked Information Holder: {(ID,D1,..,DN,L} for HATEOAS, e.g. "nextPage":Link<Customer>* 
	| 'Data'
	| 'Metadata'
	| 'Identifier'
	| 'Link' 
//	| ActionCode
;

/*
// experimental, not documented (may disappear at any time)
ActionCode:
	'CREATE' | 'FULL_UPDATE' | 'PARTIAL_UPDATE' | 'DELETE' | 'GET' | 'MORE_DATA' | other=STRING
;
*/ 

BasicDataType:
	// TODO specify and document value ranges (same as OAS? CloudEvents?) abstract level or binding?
 	'bool' | 'int' | 'long' | 'double' | 'string' | 'raw' | 'void' // 'record', 'map' and 'array' do not make sense here; TODO how about 'date'?
	;

Cardinality:
	zeroOrOne='?' | zeroOrMore='*' | atLeastOne='+' | exactlyOne='!'
;


// *** Part B: service endpoint contracts (with operations)

EndpointContract:
	'endpoint' 'type' name=ID 
	('version' svi=SemanticVersioningIdentifier)? 
	// TODO (M) support multiple ('+= ...*')? 
	('supports' ('flow' flow=[Orchestration]|'scenario'scenario=[IntegrationScenario]))? // TODO could go from '?' to '*' here
	('serves' 'as' primaryRole=ResourceRole ('and' otherRoles+=ResourceRole)* 'role'?)?
	sp=SecurityPolicy?
	('exposes' ops+=Operation+)? // optional because early incomplete specifications do not have to expose any operations 
	// ('emits' events+=Event+)? // done on operation level (TODO tbd: add here too?)
	('receives' events+=Event+)? // experimental in V5.1
;

// TODO (done) added stereotypes for 'STATEFUL_PROCESSING_RESOURCE' (CFs only?) and 'STATELESS_PROCESSING_RESOURCE', VALIDATION_RESOURCE and taken out two old MAP names T_R and L_R
ResourceRole: 'PROCESSING_RESOURCE' | 'INFORMATION_HOLDER_RESOURCE' | 'OPERATIONAL_DATA_HOLDER' | 'MASTER_DATA_HOLDER' | 'REFERENCE_DATA_HOLDER' /* | 'TRANSFER_RESOURCE' | 'LOOKUP_RESOURCE' */ | 'DATA_TRANSFER_RESOURCE' | 'LINK_LOOKUP_RESOURCE' | 'STATEFUL_PROCESSING_RESOURCE' | 'STATELESS_PROCESSING_RESOURCE' | 'VALIDATION_RESOURCE' | STRING;

Event: 
	'event'
	type=[EventType]
	('version' svi=SemanticVersioningIdentifier)?
;
 
// TODO tbd/tbc how would service contracts for Web Sockets conversations look like? [R, O]

Operation:
	'operation' 
	name=ID 
	('version' svi=SemanticVersioningIdentifier)?
	('with' 'responsibility' responsibility=OperationResponsibility)? 
	// TODO add ('supporting' stakeholder=STRING // for actor from story
	('in'  mep=MessageExchangePattern 'conversation')? 
	('expecting' requestMessage=DataTransferRepresentation)? // request message is optional
	('delivering' responseMessage=DataTransferRepresentation 
	  ('links' relations+=RelationshipLink+)? // optional within 'delivering'
	  ('reporting' reports=StatusReports)? // optional within 'delivering'
	)? // response message is optional 
	('transitions' st=StateTransition)? // or IDs, [Refs], to be defined above? [R] export as OpenAPI comment?
	('emitting' events+=Event+)? // or 'publishing'? 'sending'? `producing`?
	('compensated' 'by' undo=[Operation])? // could also be expressed as link relation
	('protected' 'by' policies=SecurityPolicies)?
;

// TODO tbd/tbc CML is more expressive here, see https://contextmapper.org/docs/aggregate/
// methods can define read, read-write, etc. (done via MAP role decorators here); state machine is on Aggregate level in CML
StateTransition:
	'from' from=STRING 'to' to=STRING
;

RelationshipLink:
	name=STRING ':' lcref=[LinkContract]
;

StatusReports:
	reportList+=StatusReport+
;

StatusReport:
	('status' | 'error' | 'analytics') name=ID reportData=ElementStructure?
;

SecurityPolicies:
	policyList+=SecurityPolicy+
;

SecurityPolicy: 
	 'policy' name=ID securityObject=ElementStructure?
;

// TODO implement new ones in validators and OAS generator, use/document variants consistently, document them (updated keywords in V5.3)
// new variants (required for HTTP verb mapping): STATE_REPLACEMENT_OPERATION and STATE_DELETION_OPERATION (better: "FULL_UPDATE_OPERATION" and "PARTIAL_UPDATE_OPERATION"?) and STATE_DELETION_OPERATION
OperationResponsibility: cf='COMPUTATION_FUNCTION' | sco='STATE_CREATION_OPERATION' | ro='RETRIEVAL_OPERATION' | sto='STATE_TRANSITION_OPERATION' | ep='EVENT_PROCESSOR' | bap='BUSINESS_ACTIVITY_PROCESSOR' | sro='STATE_REPLACEMENT_OPERATION' | sdo='STATE_DELETION_OPERATION' | other=STRING;
// EVENT_PROCESSOR is a variant of SCO, BUSINESS_ACTIVITY_PROCESSOR is a variant of STO

MessageExchangePattern: 'ONE_WAY' | 'REQUEST_REPLY' | 'NOTIFICATION' | STRING; // TODO [O, R] add SERVER_SENT_EVENTS and gRPC 1:n, n:1, n:m streaming?  
	
DataTransferRepresentation:
	('headers' headers=ElementStructure)? 
	'payload' payload=ElementStructure // this could be an embedded XSD or JSON Schema (or an external one referenced via URI, see V4.x bindings)
	('structured' 'as' ts=TypeSystem)? 
;

TypeSystem: 
	'MAP_TYPE' | 'JOLIE_TYPE' | 'JSON_SCHEMA' | 'XML_SCHEMA' |'PROTOCOL_BUFFER' | 'AVRO_SCHEMA' | 'THRIFT_TYPE' | 'GRAPHQL_SDL' | 'OTHER' | STRING 
;

// AsyncMDSL extensions: 

// TODO add flow/scenario link (see endpoint contract)?
ChannelContract:
	'channel' name=ID
	// not yet:	('supports' ('flow' flow=[Orchestration]|'scenario'scenario=[IntegrationScenario]))? // TODO could go from '?' to '*' here
	('of' 'type' types+=ChannelType (',' types+=ChannelType)*)?
	('delivery' 'guarantee' quality=DeliveryGuarantee)?
	conversationType=(RequestReplyChannel|OneWayChannel) // TODO a channel should be able to transfer messages of multiple (data) types
;

enum ChannelType:
	POINT_TO_POINT | PUBLISH_SUBSCRIBE | DATA_TYPE | INVALID_MESSAGE | DEAD_LETTER | GUARANTEED_DELIVERY
;

// Xtext initializes 'quality' using the first value of this enum,
// that will act as null and default value
enum DeliveryGuarantee:
	UNKNOWN | AT_LEAST_ONCE | AT_MOST_ONCE | EXACTLY_ONCE 
;

BindingValue:
	{BindingValue} str=STRING | {BindingValue} number=INT | bool=('true' | 'false')
;

BindingParameter:
	name=STRING ':' value=(BindingValue | BindingParams)
;

BindingParams:
	'{'
		params+=BindingParameter
		(',' params+=BindingParameter)*
	'}'
;

BasicParameterWithDescription:
	paramName=ID ':' type=BasicDataType (',' description=STRING)?
;

ChannelPathWithParams:
	'path' path=STRING
	('with' 
		params+=BasicParameterWithDescription
		(',' params+=BasicParameterWithDescription)?
	)?
;

RequestReplyChannel:
	request=RequestChannel
	reply=ReplyChannel

;

RequestChannel:
	'request' 'message' name=ID 
		(('description' description=STRING)? &
		'on' path=ChannelPathWithParams)
		'expecting' payload=Payload
		('where' whereClauses+=WhereClauses (',' whereClauses+=WhereClauses)*)?
		('bindings' 'for' protocol=ProtocolBinding bindings=BindingParams)? 
;

ReplyChannel:
	'reply' 'message' name=ID 
		(('description' description=STRING)? &
		'on' path=ChannelPathWithParams)
		'delivering' payload=Payload
		('where' whereClauses+=WhereClauses (',' whereClauses+=WhereClauses)*)?
		('bindings' 'for' protocol=ProtocolBinding bindings=BindingParams)?
;

Payload:
	schema=DataTransferRepresentation	
	('as' messageType=MessageType)?
;

// TODO tbd/tbc acceptsAndProduces= (now) or acceptsAndProduces?= (see other options)?
OneWayChannel:
	(('description' description=STRING)? &
	'on' path=ChannelPathWithParams)
	(subscribe?='accepts' | publish?='produces' | acceptsAndProduces='accepts' 'and' 'produces') message=Message // TODO more than one (data) type?
	('where' whereClauses+=WhereClauses (',' whereClauses+=WhereClauses)*)? // impact on where clauses if multiple message types can be exchanged?
	('bindings' 'for' protocol=ProtocolBinding bindings=BindingParams)?
;

Message:
	'message' name=ID 
	('description' description=STRING)?
	(deliveringPayload?='delivering' | expectingPayload?='expecting') payload=Payload
;

WhereClauses:
	MessageExpireWhereClause
	|	SequenceIdWhereClause
    |	CorrelationIdWhereClause
;

MessageExpireWhereClause:
	'MESSAGE_EXPIRES' 'in' messageExpire=INT messageExpireUnit=MessageExpireUnit
;

SequenceIdWhereClause:
	'SEQUENCE_ID' 'is' expression=STRING
;

CorrelationIdWhereClause:
	'CORRELATION_ID' 'is' source=STRING
;

enum MessageExpireUnit:
	s | m // seconds or minutes
;

enum MessageType:
	COMMAND_MESSAGE | EVENT_MESSAGE | DOCUMENT_MESSAGE
;


// *** C.1: provider/endpoint part 

Provider:
	'API' 'provider' // | ms= 'Message' 'sender' (MOM support was experimental)
	name=ID
	('version' svi=SemanticVersioningIdentifier)? 
	// ('contained' 'in' parent=[Provider])? // removed implement this "subresourcing" (OAS has it), superseeded by new binding
	epl+=EndpointList+ // [Q] is list here (+) and in EndpointInstance needed (*)? 
	('under' 'conditions' tsandcs=STRING | 'with' 'provider' sla=SLA)? // neither Ts&Cs nor SLA must be present
	('provider' 'governance'  evolStrat=EvolutionStrategy)? 
;

EndpointList:	
	'offers' contract=[EndpointContract] // one endpoint can only offer a single contract (but provider can have multiple endpoints)
	endpoints+=EndpointInstance* // optional; several endpoints per contract mean redundant deployment (or different SLAs for same functionality) 
;

EndpointInstance: 
	'at' 'endpoint' 'location' location=STRING // TODO try to rename: "name" triggers XText uniqueness check, not desired here (?) 
	pb+=TechnologyBinding+ // changed from * to + on Dec 12, 2020 (documentation TODO)
	('with' 'endpoint' sla=SLA)? // SLA is optional
	('endpoint' 'governance'  evolStrat=EvolutionStrategy)?
;

MessageBroker:
	'message' 'broker' name=ID
	('description' description=STRING)?
	('exposes' epl+=AsyncEndpoint (',' epl+=AsyncEndpoint)?)+
	
;

AsyncEndpoint:
	contracts+=[ChannelContract] (',' contracts+=[ChannelContract])*
	'at' 'location' location=STRING
	pb=TechnologyBinding
	('bindings' bindings=BindingParams)?
	('policy' name=ID 'realized' 'using' securityPolicy=OASSecurity ('in' securityPolicyExpression=STRING)?)? 
;


// ** technology binding (simple/advanced)

TechnologyBinding:
	'via' 'protocol' protBinding=ProtocolBinding 
;

ProtocolBinding:
	http=HTTPBinding | java=JavaBinding | grpc=GRPCBinding | other=OtherBinding
;

HTTPBinding:
	http='HTTP' ('static'|'dynamic')? 'binding' eb+=HTTPResourceBinding+
;

HTTPResourceBinding:
	// decided not make resource name=ID ... optional (used in binding)
    'resource' name=ID ('at' uri=STRING)? (tB+=HTTPTypeBinding* opsB+=HTTPOperationBinding+)?
;

CustomMediaType: 
	// TODO support full RFC as enum and do more with custom MIME types (required for REST maturity level 3)
	'media' 'type' name=ID 'as' value=STRING 
;

HTTPTypeBinding:
	CustomMediaType
	| 'data' 'type' dt=[DataContract] 'to' (mt+=[CustomMediaType] | smt+=StandardMediaType)+
	| 'relation' 'type' lt=[LinkContract] 'to' hml=HypermediaLink 
	// TODO (tbd) anything to be bound for event types and command types (new features in V5.3)? 
;

StandardMediaType:
	ianaName=STRING // link types vs. MIME types
;

HypermediaLink: // this is the DAP concept from "REST in Practice" 
	// TODO use or reference JSON-LS or HAL or IANA or ALPS or ...?
	'{' (local=[HTTPResourceBinding]|external=STRING) (',' verb=HTTPVerb (',' cmt=[CustomMediaType])?)? '}'
;

HTTPOperationBinding:
	// would like to reference [Operation] here; Xtext runs through but editor does not show references (?)  
	'operation' boundOperation=ID 'to' method=HTTPVerb ('at' subresource=STRING)? // TODO implement in oasgen
	(parameterBindings+=HTTPParameterBinding* | globalBinding=HTTPGlobalParameterBinding)
	reportBindings+=ReportBinding* // TODO for Java (and others)?
	securityBindings+=SecurityBinding* // TODO for Java (and others)?
	('accepts' inContentTypes=MediaTypeList)?
	('replies' outContentTypes=MediaTypeList)?
;

MediaTypeList:
	(cmt+=[CustomMediaType] | smt+=StandardMediaType)+
;

HTTPGlobalParameterBinding:
	'all' 'elements' 'realized' 'as' parameterMapping=HTTPParameter 'parameters'
;

// would like to use [ElementStructure] here but it does not have name=ID, 5.0.2 STRING now (consistency!
HTTPParameterBinding:
	'element' (boundParameter=STRING) 'realized' 'as' parameterMapping=HTTPParameter 'parameter' ('with' details=ElementStructure)? // type vs. instance elementStructureInstance rule?
;

enum HTTPVerb: GET | PUT | POST | PATCH | DELETE | HEAD | OPTIONS | TRACE
;

enum HTTPParameter: QUERY | HEADER | PATH | COOKIE | BODY // semantic rule: BODY is default; OAS: "query", "header", "path" or "cookie" (plus "formData" in Swagger2)
;

ReportBinding:
	'report' name=ID 'realized' 'as' httpStatusCode=INT ('with' details=STRING)?
;

SecurityBinding:
	// [SecurityPolicy] reference?
	'policy' name=ID 'realized' 'as' http=OASSecurity ('with' keys+=ID values+=STRING)*
;

enum OASSecurity: BASIC_AUTHENTICATION | JWT | API_KEY | OAUTH_IMPLICIT | OAUTH_FLOW | String; // any default?


JavaBinding:
	java='Java' (binding='binding' ('package' package=STRING)? opsBinding+=JavaOperationBinding+)?
;

JavaOperationBinding:
	'operation' boundOperation=ID 'to' method=STRING // no "subresource" here
	pB+=JavaParameterBinding*
;

JavaParameterBinding:
	'element' (boundParameter=ID|any='*') 'realized' 'as' pm=JavaParameter 'type' // HTTP has more here
;

enum JavaParameter: byte | short | int | long | float | double | boolean | char | String; // TODO String needed? or object/DTO required?


GRPCBinding:
	gRPC='gRPC' (binding='binding' opsBinding+=GRPCOperationBinding+)?
;

GRPCOperationBinding:
	'operation' boundOperation=ID ('to' method=STRING)? ('as' so=StreamingOption 'stream')?
;

enum StreamingOption:
	client | server | bidirectional // if not present, "unary" is assumed
;


OtherBinding:
    soap='SOAP_HTTP' | jsonrpc='JSON-RPC' | avro='Avro_RPC' | thrift='Thrift' | ws='Web_Sockets' | amqp='AMQP' | jms='JMS_ActiveMQ' | stomp='STOMP' | kafka='Kafka' | mqtt='MQTT' | other=STRING 
;


// **** SLA

SLA:
	'SLA' (builtin=InternalSLA | external=[SLATemplate])
;

SLATemplate:
	'SLA' 'template'
	name=ID
	slas+=InternalSLA
;

InternalSLA:
	('type' type=SLAType)? // note: not checked/used at present (semantic check?) 
	slos+=SLO+
	('penalty' penalties=STRING)?
	('notification' reporting=STRING)?
	rp=RatePlan? 
	rl+=RateLimit*
;

RatePlan:
	'rate' 'plan' ('FREEMIUM' | "SUBSCRIPTION" | "USAGE_BASED") // note: actual pricing not modeled yet
;

RateLimit:
	'rate' 'limit' (none='NONE' | "MAX_CALLS" callRate=SimpleMeasurement | "DATA_QUOTA" dataRate=SimpleMeasurement) "within" interval=SimpleMeasurement// note: just a PoC/demo, can be modeled much better (see pattern/books)	
;

enum SLAType: 
	NONE  | IMPLICIT | INFORMAL | QUALITATIVE | QUANTITATIVE
;

SLO:
	'objective' 
    name=ID
	qualityGoal=STRING
	// ':'  
	measurement=Measurement
;

Measurement:
	sm=SimpleMeasurement | lz=LandingZone
;

SimpleMeasurement:
	value=INT
	unitOfMeasure=('hours' | 'minutes' | 'seconds' | 'MB' | 'GB'| ID | STRING)? // not a full specification of units/measures, just a PoC/demo
;

LandingZone:
	'minimal' s=SimpleMeasurement
	'target' t=SimpleMeasurement
	('optimal' o=SimpleMeasurement)?
;

// **** evolution

enum EvolutionStrategy: 
	ETERNAL_LIFETIME | LIMITED_GUARANTEED_LIFETIME | TWO_IN_PRODUCTION | AGGRESSIVE_OBSOLESCENCE | EXPERIMENTAL_PREVIEW // MAPs
	| OTHER_STRATEGY | UNDISCLOSED // default: UNDISCLOSED
;


// *** C.2: Client 

Client:
	'API' 'client' name=ID
	('version' svi=SemanticVersioningIdentifier)? 
     cons+=Consumption+
;

Consumption: 
	'consumes' contract=[EndpointContract]
	// if present, the provider reference creates a fixed binding between client and server:
	('from' providerReference=[Provider] | 'through' gatewayReference=[Gateway])? // could also go down to endpoint level
	('via' 'protocol'  binding+=ClientBinding)? // must match provider-side information (linter!)
	// old syntax required resource binding to be specified since V5.0 (for HTTP protocol); this is fixed now (in slightly incompatible way)
;

ClientBinding:
    http='HTTP' | grpc='gRPC' | java='Java' | OtherBinding // TODO add more precision, e.g. implementation info such as Feign?
;

MessageEndpoint:
	'message' 'endpoint' name=ID
	('of' 'type' types+=MessageEndpointType (',' types+=MessageEndpointType)*)?
	('serves' 'as' primaryRole=ResourceRole (',' otherRoles+=ResourceRole)* 'role'?)?
	('description' description=STRING)?
	'uses' 
		('channels' ':'
			channelsNoBroker+=AsyncConsumptionWithProtocolBinding (',' channelsNoBroker+=AsyncConsumptionWithProtocolBinding)*
		)?
	(channels+=AsyncConsumptionFromBroker (',' channels+=AsyncConsumptionFromBroker)*)?
;

enum MessageEndpointType:
	TRANSACTIONAL_CLIENT | POLLING_CONSUMER | EVENT_DRIVEN_CONSUMER | IDEMPOTENT_RECEIVER | MESSAGING_GATEWAY | MESSAGING_MAPPER | COMPETEING_CONSUMER | MESSAGE_DISPATCHER | SELECTIVE_CONSUMER | DURABLE_SUBSCRIBER | SERVICE_ACTIVATOR // typo fixed, TODO test
;

AsyncConsumptionFromBroker:
	'from' broker=[MessageBroker] ':'
	channels+=AsyncConsumptionNoProtocolBinding (',' channels+=AsyncConsumptionNoProtocolBinding)*
	(binding+=ProtocolBinding)?
;

// this rule is actually used, [reference] in next two rules:
Channel:
	ChannelContract | RequestChannel | ReplyChannel
	// TODO (M) change to cc=ChannelContract | reqc=RequestChannel | repc=ReplyChannel (impact on Xtend?)
;

AsyncConsumptionNoProtocolBinding:
	(channel=[Channel])
	(where=WhereConstruct)?
;

AsyncConsumptionWithProtocolBinding:
	(channel=[Channel])
	(where=WhereConstruct)?
	(binding+=ProtocolBinding)?
;

WhereConstruct:
	{WhereConstruct} 'where' 
	(whereClauses+=ConsumptionWhereClauses (',' whereClauses+=ConsumptionWhereClauses)*)?
		((',')? 'all' 'subscriptions' 'are' 'durable')?
;

ConsumptionWhereClauses:
		'consumed' 'if' leftExp=STRING op=BinaryOperator rightExpr=IfExpr
;

IfExpr:
	STRING | INT
;
BinaryOperator:
	'==' | '!=' | '>' | '<' | '<=' | '>='
;

// *** C.3: Gateway (experimental)

Gateway:
	('API' 'gateway' ) name=ID // | 'Message' 'broker' removed, was experimental
	('version' svi=SemanticVersioningIdentifier)? 
	gateList+=Gate+ // TODO need to implement validators (and adjust existing HTTP binding one)
	('evolution' 'governance' evolStrat=EvolutionStrategy)?
;

Gate:
	( 'offers' )  upstreamContract+=[EndpointContract]+ // | 'publishes' removed, was experimental
	endpoints+=EndpointInstance+ 
    cons+=Consumption
    ('mediates' dts+=DataTransformation)*
;

DataTransformation:
	'from' indc=[DataContract] 'to' outdc=[DataContract] // TODO (V5.3, V6.0): add implementation hook/exit/callback info?
;


// *** C.4: Provider Implementation (experimental)

ProviderImplementation:
	'API' 'provider' 'implementation'
	name=ID
	'realizes' upstreamBinding=[Provider]
	'in' platform=ImplementationTechnology
	('as' class=STRING ('extending' superclass=STRING)? // default assigned if not specified
	| 'with' 'binding' downstreamBinding=[Provider])? // reference to Java protocol binding (optional)
;

// TODO add Data Transformation here (an API implementation may have data model that differs from that of API)
// it can be seen as a gateway from HTTP to local Java so might not need this grammar part at all (tbd) 

enum ImplementationTechnology: PlainJava /* | SpringMVC | vlingo */ | STRING
;	


// *** D: Service Orchestration (Events, Commands) and Integration Stories

IntegrationScenario:
	'scenario' name=ID ('type' type=ScenarioType)? stories+=IntegrationStory* // TODO could add related+=RelatedScenarios*
 ;

enum ScenarioType:
	BUSINESS_API | FRONTEND_INTEGRATION_SCENARIO | BACKEND_INTEGRATION_SCENARIO // tbd others?
;

IntegrationStory:
	('story' name=ID ('type' type=StoryType)? related+=RelatedStories*)? // for compatibility
	('when' condition=STRING)? 
	('a'|'an'|'the') (client=STRING | 'API' 'client') // location, description? 
	// action can become command detail (data?)
	'wants' 'to' action=Action on+=StoryObject* // TODO add attributes and relations too (see CML)?
	('yielding' outcome=STRING)? // postcondition 
	('so' 'that' goal=STRING)? // business impact/effect
;

Action:
	plainAction=STRING | keyword=ActionKeyword ('a'|'an'|'the')? target=STRING // TODO could try '*' here (CRUD in single story)
;

// experimental:
enum ActionKeyword:
	CRUD | CQRS // TODO tbd, add something for MAP stories, e.g. DTR, LLR? 
	// most keywords break operation naming - if present, operations can't be called create etc. (tests fail too)
	// create | read | update | delete | search | lookup | replace | add | remove 
;

// TODO 5.3.1: add 'on' and 'from'
StoryObject:
	('with'|'against'|'for'|'at'|'in'|'to')? ('a'|'an'|'the')? object=STRING // more=StoryObject 
;

enum StoryType:
	USER_STORY | JOB_STORY | TEST_CASE | API_MOCK // analysis vs. design? 
;

RelatedStories:
	'follows' related+=[IntegrationStory] | 'alternative' 'to' related+=[IntegrationStory] | 'parallel' 'to' related+=[IntegrationStory]
;

// flow syntax adapted from CML grammar at https://github.com/ContextMapper/context-mapper-dsl/blob/master/org.contextmapper.dsl/src/org/contextmapper/dsl/ContextMappingDSL.xtext

Orchestration:
	'flow' name=ID ('realizes' scenario=[IntegrationScenario])? ('type' type=FlowType)? 
	steps+=FlowStep* 
	flowBinding=OrchestrationBinding?
;

enum FlowType: 
	APPLICATION_FLOW  | INTEGRATION_FLOW /* EIP */ | SERVICE_ORCHESTRATION | API_CALL_SEQUENCING /* conversation in MAP */ | EVENT_SOURCING
;

// experimental flow binding (not from CML):
 
OrchestrationBinding:
	'binding' /* 'flow' */ 'to' (eptb+=EndpointTypeBinding|cb+=ChannelBinding)+
	('implemented' 'as' ft=FlowTechnology)? // TODO add detailed information required for code generation, e.g., Aggregator timeouts in Camel
;

EndpointTypeBinding:
	'endpoint' 'type' epcs+=[EndpointContract] stepBindings+=StepToEndpointBinding* ('provider' provider=[Provider])? // and/or ('client' client=[Client])? or Gateway?
;

ChannelBinding:
	'channel' 'type' channels+=[ChannelContract] stepBindings+=StepToChannelBinding* ('provider' provider=[MessageBroker])? // TODO test; add MessageEndpoint too?
;

FlowTechnology:
	'APACHE_CAMEL_ROUTE' | 'SPRING_INTEGRATION_FLOW' | 'BPMN_PROCESS' | 'BPEL_PROCESS' | 'YET_ANOTHER_FLOW_LANGUAGE' | 'PLAIN_PROGRAMMING' | STRING // TODO test (do I get to the strings this way, prefixes needed?)
;

StepToEndpointBinding:
	eob=EventToOperationBinding | cob=CommandToOperationBinding // tbd: e.g. Feign or JAX-RS as impl. tech.?
;

StepToChannelBinding:
	emb=EventToMessageBinding | cmb=CommandToMessageBinding // tbd: e.g. Feign or JAX-RS as impl. tech.?
;

EventToOperationBinding:
	'event' event=[EventType] 'to' 'operation' operation=ID // TODO validate ID in linter
	('with' 'mediation' dt=DataTransformation)? // TODO experimental: test, document
;

CommandToOperationBinding:
	'command' command=[CommandType] 'to' 'operation' operation=ID // TODO validate ID in linter
	('with' 'mediation' dt=DataTransformation)? // TODO experimental: test, document
;

EventToMessageBinding:
	'event' event=[EventType] 'to' 'message' requesReplyChannelMessage=ID // AsyncMDSL: [Message] not possible
	// TODO mediation? could be separate channel/filter/channel config. with ContentFilter, etc. (EIPs)
;

CommandToMessageBinding:
	'command' command=[CommandType] 'to' 'message' oneWayChannelMsg=ID // AsyncMDSL: [Message] not possible
	// TODO mediation? could be separate channel/filter/channel config. with ContentFilter, etc. (EIPs)
;
	
// ServiceOperation: (typeref=ID '.')? opref=ID; // can't reference [operations], regrettably

FlowStep:
	depStep=DomainEventProductionStep | cisStep=CommandInvokationStep | eceStep=CombinedInvocationStep
;

// TODO add <<EIP>> decorators, for instance for Aggregation strategy and wait behavior

CombinedInvocationStep:
	cisStep=CommandInvokationStep ('emits'|'emit') ('event'|'events') eventProduction=EventProduction
;

DomainEventProductionStep:
	// this corresponds to app flow state transitions in CML, see https://contextmapper.org/docs/application-and-process-layer/
	// simplified not to break SOAD refinement flow, renamed aggregate=[EndpointContract] to contractAndOperation=[EndpointContract]
	action=EitherCommandOrOperation /* ('delegates' 'to' contractAndOperation=[EndpointContract] ('[' stateTransition=StateTransition ']')?)?  */ ('emits'|'emit') ('event'|'events') eventProduction=EventProduction
;

// no OR, no XOR here (not needed/wanted):
CommandInvokationStep:
	('event'|'events') events+=[EventType] (('+' | 'and' ) events+=[EventType])* ('triggers'|'trigger') action=EitherCommandOrOperationInvokation
;

// no AND, OR, no XOR here (not needed/wanted? check CML)
EitherCommandOrOperation:
	('command' command=[CommandType] /* | 'operation' operation=ServiceOperation */) ('[' 'initiated' 'by' actor=STRING ']')?
;

EitherCommandOrOperationInvokation:
	ci=CommandInvokation | spi=SubProcessInvocation /* | oi=OperationInvokation */ // taken out (from CML)
;

SubProcessInvocation:
	'flow' subprocess=[Orchestration] // TODO test
;

CommandInvokation:
	('command'|'commands') (sci=SingleCommandInvokation | cci=ConcurrentCommandInvokation | eaci=ExclusiveAlternativeCommandInvokation | iaci=InclusiveAlternativeCommandInvokation)
;

SingleCommandInvokation:
	commands+=[CommandType]
;

ConcurrentCommandInvokation:
	commands+=[CommandType] (('+' | 'and' ) commands+=[CommandType])+
;

ExclusiveAlternativeCommandInvokation:
	commands+=[CommandType] (('X' | 'x' | 'alternatively' ) commands+=[CommandType])+
;

InclusiveAlternativeCommandInvokation:
	commands+=[CommandType] (('O' | 'o' | 'or' ) commands+=[CommandType])+
;

// operation related rules from CML removed

EventProduction:
	sep=SingleEventProduction | mep=MultipleEventProduction | eaep=ExclusiveAlternativeEventProduction | iaep=InclusiveAlternativeEventProduction
;

SingleEventProduction:
	events+=[EventType]
;

MultipleEventProduction:
	events+=[EventType] (('+' | 'and' ) events+=[EventType])+
;

ExclusiveAlternativeEventProduction:
	events+=[EventType] (('X' | 'x' | 'alternatively') events+=[EventType])+
;

InclusiveAlternativeEventProduction:
	events+=[EventType] (('O' | 'o' | 'or') events+=[EventType])+
;

// ** End of MDSL grammar 
