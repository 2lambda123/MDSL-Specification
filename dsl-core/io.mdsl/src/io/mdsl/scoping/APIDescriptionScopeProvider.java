/*
 * generated by Xtext 2.20.0
 */
package io.mdsl.scoping;

import java.util.List;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import io.mdsl.apiDescription.ApiDescriptionPackage;
import io.mdsl.apiDescription.AsyncConsumptionNoProtocolBinding;
import io.mdsl.apiDescription.AsyncConsumptionWithProtocolBinding;
import io.mdsl.apiDescription.Channel;
// import io.mdsl.apiDescription.ConsumptionWhereClauses;
// import io.mdsl.apiDescription.Message;

/**
 * This class contains custom scoping description.
 * 
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
public class APIDescriptionScopeProvider extends AbstractAPIDescriptionScopeProvider {

	@Override
	public IScope getScope(EObject context, EReference reference) {

		if (context instanceof AsyncConsumptionNoProtocolBinding
				&& reference == ApiDescriptionPackage.eINSTANCE.getAsyncConsumptionNoProtocolBinding_Channel()) { //  Literals.ASYNC_CONSUMPTION_NO_PROTOCOL_BINDING__CHANNEL) {
			// TODO: should select only channels available from parent broker
			EObject rootElement = EcoreUtil2.getRootContainer(context);
			List<Channel> candidates = EcoreUtil2.getAllContentsOfType(rootElement, Channel.class);
			return Scopes.scopeFor(candidates);
		}

		if (context instanceof AsyncConsumptionWithProtocolBinding
				&& reference == ApiDescriptionPackage.eINSTANCE.getAsyncConsumptionWithProtocolBinding_Channel()) { // Literals.ASYNC_CONSUMPTION_WITH_PROTOCOL_BINDING__CHANNEL) {
			EObject rootElement = EcoreUtil2.getRootContainer(context);
			List<Channel> candidates = EcoreUtil2.getAllContentsOfType(rootElement, Channel.class);
			return Scopes.scopeFor(candidates);
		}

		return super.getScope(context, reference);
	}

}
